# 解法

## efficient1
```
B$ L! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! B$ v! I" L! B+ B+ v! v! B+ v! v!
```

という入力だが、これは1段階評価する (最初の `L!` に `L! B+ B+ v! v! B+ v! v!` を代入する)と

$$
  f(x) = (x+x) + (x+x)
$$

を 22 回適用させて 1 を代入した 

$$
f(f(f(f \cdots (f(1))))
$$

という形になる。
ただ後の評価を素直にすると

$$
\begin{split}
f^{22}(1) &= f^{21}(1)+f^{21}(1)+f^{21}(1)+f^{21}(1)\\
&= f^{20}(1)+\cdots (14個のf^{20}(1))\cdots+f^{20}(1)\\
&= f^{19}(1)+\cdots (62個のf^{19}(1))\cdots+f^{19}(1)\\
\end{split}
$$

と外から評価するので遅くなっている。

ざっと速くする方法は 2 種類あって、1 つは遅延評価するために `B$` を `B~` にして `echo` にかける方法。これは内側からの展開になるので楽。
もう 1 つは、そもそも数式を展開しなくていいように `B+ B+ v! v! B+ v! v!` ( $(x+x)+(x+x)$ ) の部分を `B* v! I%` ($4x$) に変更すること。
いずれもあっという間に $4^{22}$ という結果が出てくる。

## efficient2
問題を parse すると、途中に長ったらしい色々はあるが実は
```
B+
  I7c (=2134)
  B*
    (長い式)
    I! (=0)
```
となっている。つまり数式的には

$$
2134 + (長い式) \times 0
$$

となっているので答えは 2134

## efficiency3
今度は efficiency2 で 0 だった部分が 1 になっているので長い式の部分を評価する必要がある…のだが、面倒なので引数の `I":c1+0`(=9345873499) の部分を変えて 0 やら 1 やら代入してみると、なんとなく

$$
2134+1+n
$$

という結果になりそうなのでそれを信じて `solve` を投げる。

## efficiency4
最後にある
```
L$ L% ? B< v% I# I" B+ B$ v$ B- v% I" B$ v$ B- v% I#
```
は要するに
```rust
x3 = |x4| => if x4 < 2 {
  1
} else {
  x3(x4 - 1) + x3(x4 - 2)
}
```
となってるので、Fibonacci 数列っぽい。ついでに引数となっている `II`(=40) を変えていくつか確認すると大丈夫なようなので Fibonacci 数列の 41 番目を答える。

## efficiency5
ちょっと長いが、適宜読みやすく parser で変換して少しずつ解読していこう。

まずは序盤に
```rust
x3 = |x4| => if x4 > 1000000 && x6(x4) && x7(x4 + 1) {
  x4
} else {
  x3(x4 + 1)
}
```
とある。まだ `x6` と `x7` がどんな関数なのかわからないが、 $f_6(x)$ と $f_7(x+1)$ を満たす $x>10^6$ で最小の数を見つけそうだということが分かる。

他には真ん中あたりから
```rust
x3 = |x4| => if x4 == 1 {
  true
} else if x4 % 2 == 1 {
  false
} else {
  x3(x4 / 2)
}
```
```rust
x3 = |x4| =>
if x4 == x5 {
  true
} else if x5 % x4 == 0 {
  false
} else {
  x3(x4 + 1)
}
```
となる関数を発見できる。前半は 2 のべき乗であるかを判断する関数、後半は `x5` の素数判定だと解る。

最初のと合わせると適用順序から `x7` が 2 のべき乗判定、`x6` が素数判定と考えられるので、最初のコードは
```rust
x3 = |x4| => if x4 > 1000000 && is_prime(x4) && is_power_of_2(x4 + 1) {
  x4
} else {
  x3(x4 + 1)
}
```
となるので、要はメルセンヌ素数の判定と思われる。 $10^6$ を超える最小のメルセンヌ素数は $2^{31}-1$

## efficiency6
efficiency5 と同様に冒頭が
```rust
x3 = |x4| => if x4 > 30 && x6(x7(x4)) {
  x4
} else {
  x3(x4 + 1)
}
```
となっているので、また 2 関数 `x6` `x7` を見つけたい。その実装も読みやすく変更していれば見つけやすく
```rust
x3 = |x4| => if x4 < 2 {
  1
} else {
  x3(x4 - 1) + x3(x4 - 2)
}
```
```rust
x3 = |x4| => if x4 == x5 {
  true
} else if x5 % x4 == 0 {
  false
} else {
  x3(x4 + 1)
}
```
である。前の方が Fibonacci 数列の生成、後ろの方は素数判定である。

纏めると求めたいのは素数になっている 30 番目以降で最初の Fibonacci 数が何番目か、ということになる。そして該当するのは $F_{42}=433494437$ である。($F_0=F_1=1$で数える)

## efficiency7
前半は 40 変数の SAT が書かれていて、後半を見ると 40 変数には何かの数の bit が対応する事がわかる。(`x40` が MSB、`x1` が LSB)

ということで SAT Solver の [Z3](https://github.com/Z3Prover/z3) を導入するのが手っ取り早い。

ちなみに条件部分は 1~3 変数を OR で繋いだ項を大量に AND で繋いだ形になっている。

SAT Solver を回し、割り当ては 1 からインクリメントしていることを考慮して数を求める。

## efficiency8
変数が 50 個になった他は基本的に efficiency7 と同じ。後になって author の write up を見ると efficiency7 は唯一解、efficiency8 は複数解となっているらしい。

## efficiency9
efficiency7,8 と比較すると変数の数が増えた他、値自体が `1 + x1 / 22876792454961 % 9` のように 1 から 9 の数になっている。こちらも後で write up を見ると数独の問題だったらしいが、そんな前提はわからないので SAT として解く。

上に書いたように各変数は 1 から 9 のどれかなので、`x11 == 1 OR x11 == 2 OR x11 == 3 ... OR x11 == 9` のような条件を全変数に対して付け加え、`x11` を最上位桁、 `x99` を最下位桁として 0~8 の 9 進数と思って答えを求める。