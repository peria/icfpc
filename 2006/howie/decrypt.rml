use uploader

(* decrypt.rml - RML to decrypt redacted documents. *)
(* Robot-specific serial number -- must be customized during manufacturing: *)
let SERIALNO = "A87312".

(* Common types: *)
extern type int.
type bool =
    True { }
  | False { }.
extern type string.
extern string_length : string -> int.
extern string_charat : (string, int) -> int.
extern string_fromchar : int -> string.
fun string_concat (x : string, y : string) : string = return x ^ y.
type stringlist =
    NoStrings { }
  | SomeStrings { string, stringlist }.
extern type room.
extern type item.
type direction = North { } | South { } | East { } | West { }.

(* Inputs -- what commands the robot consciousness can issue. *)
type command =
    Go { direction }
  | Take { item }
  | Incinerate { item }
  | Combine { item, item }
  | Break { item }
  | Drop { item }
  | Use { item }
  | Whistle { }
  | Hum { }
  | Speak { string }
  | LookAround { }
  | ShowInventory { }
  | Examine { item }.

(* Outputs -- data are things the robot perceives. *)
type datum =
    Atom { string }
  | Seq { datum, datum } (* value, rest of data *)
  | Assoc { string, datum, datum }  (* key, value, rest of data *)
  | NoData { }.

(* Effects on the world are also a sort of output. *)
extern move_self_to_room : room -> ().
extern move_item_to_room : (item, room) -> ().

(* Utilty functions for perceptual feedback. *)
(* Information about rooms: *)
extern room_name : room -> string.
extern room_description : room -> string.
type mayberoom = NoRoom { } | SomeRoom { room }.
extern here : () -> room.
extern room_from_name : string -> mayberoom.
extern neighbor : (room, direction) -> mayberoom.
type itemlist =
    SomeItems { item, itemlist }
  | NoItems { }.
fun itemlist_length (items : itemlist) : int =
  case items of
    NoItems { } => return 0
  | SomeItems { item, rest } => return (1 + itemlist_length (rest)).
extern room_items : room -> itemlist.

(* Information about items: *)
extern item_name : item -> string.
(* Note that the descriptions of classified items will be
 * automatically redacted downstream by the Censory Engine. This
 * also applies to any values computed from classified descriptions. *)
extern item_description : item -> string.
extern item_adjectives : item -> stringlist.
extern item_portable : item -> bool.
extern item_equals : (item, item) -> bool.

(* Each kind describes a class or group of equivalent items. *)
extern type kind.
type kindlist =
    NoKinds { }
  | SomeKinds { kind, kindlist }.
fun append_kindlists (kinds1 : kindlist, kinds2 : kindlist)
    : kindlist =
  case kinds1 of
    NoKinds { } =>
      return kinds2
  | SomeKinds { kind, kinds1 } =>
      return SomeKinds { kind,
                         append_kindlists (kinds1, kinds2) }.
(* Every item is either broken or not. If it's broken, then it's missing some
  parts. Those parts are described as a list of kinds with which it must
  be combined to be useful again. *)
type condition =
    Pristine { }
    (* 'condition' is what's left after 'missing'
      is fixed;         'missing' *)
  | Broken { condition, kindlist }.
extern kind_condition : kind -> condition.
extern item_condition : item -> condition.
extern item_matches_kind : (item, kind) -> bool.
extern fix_item : (item, condition) -> ().

fun direction_tostring (d : direction) : string =
  case d of
    North { } => return "north"
  | East { } => return "east"
  | South { } => return "south"
  | West { } => return "west".

let INVENTORY = "Inventory" ^ SERIALNO.

fun success_command (command : string, details : datum) : datum =
  return Assoc { "success",
                 Assoc { "command",
                         Assoc { command,
                                 details,
                         NoData { } },
                 NoData { } } ,
         NoData { } }.
fun failed_command (command : string, details : datum, reason : string) : datum =
  return Assoc { "failed",
                 Assoc { "command",
                         Assoc { command,
                                 details,
                         NoData { } },
                 Assoc { "reason",
                         Atom { reason },
                 NoData { } } },
         NoData { } }.

fun stringlist_to_datum (tag : string, list : stringlist) : datum =
  case list of
    NoStrings { } => return NoData { }
  | SomeStrings { s, list } =>
      return Seq { Assoc { tag, Atom { s }, NoData { } },
                   stringlist_to_datum (tag, list) }.

fun describe_condition (c : condition) : datum = [
  fun describe_kindlist (list : kindlist) : datum = [
    fun describe_kind (k : kind) : datum = [
      return Assoc { "kind",
                     Assoc { "name",
                             Atom { "" },
                     Assoc { "condition",
                             describe_condition (kind_condition (k)),
                     NoData { } } },
             NoData { } }
    ].
    case list of
      NoKinds { } =>
        return NoData { }
    | SomeKinds { kind, list } =>
        return Seq { describe_kind (kind),
                     describe_kindlist (list) }
  ].
  case c of
    Pristine { } =>
      return Assoc { "pristine", NoData { }, NoData { } }
  | Broken { c, missing } =>
      return Assoc { "broken",
                     Assoc { "condition",
                             describe_condition (c),
                     Assoc { "missing",
                             describe_kindlist (missing),
                     NoData { } } },
             NoData { } }
].

fun describe_item (item : item) : datum = [
  return Assoc { "item",
                 Assoc { "name", Atom { "" },
                 Assoc { "description", Atom { "" },
                 Assoc { "adjectives", stringlist_to_datum ("adjective",
                                                            item_adjectives (item)),
                 Assoc { "condition", describe_condition (item_condition (item)),
                 Assoc { "piled_on", NoData { },
                 NoData { } } } } } },
          NoData { } }
].

fun combine_items (big : item, small : item, flipped : bool) : datum =
  case item_condition (big) of
    Broken { condition, missing } => [
      fun find (acc : kindlist, kinds : kindlist) : datum =
         case kinds of
           NoKinds { } => [
             case flipped of
               True { } =>
                 return failed_command ("combine", Seq { describe_item (big),
                                                   Seq { describe_item (small),
                                                   NoData { } } },
                                        "they don't fit together")
             | False { } =>
                 return combine_items (small, big, True { }).
           ]
         | SomeKinds { kind, kinds } => [
            case item_matches_kind (small, kind) of
              True { } => [
                let missing = append_kindlists (acc, kinds).
                (* We maintain an invariant that the "missing" list is
                   always non-empty. *)
                case missing of
                  NoKinds { } =>
                    do fix_item (big, condition)
                | SomeKinds { kind', kinds' } =>
                    do fix_item (big, Broken { condition, missing }).
                return success_command ("combine", Seq { describe_item (big),
                                                   Seq { describe_item (small),
                                                   NoData { } } }).
              ]
            | False { } => [
                return find (SomeKinds { kind, acc }, kinds).
              ]
         ].
      return find (NoKinds { }, missing)
    ]
  | Pristine { } => [
      case flipped of
        True { } => return failed_command ("combine", Seq { describe_item (big),
                                                      Seq { describe_item (small),
                                                      NoData { } } },
                                           "they don't fit together")
      | False { } => return combine_items (small, big, True { })
    ].

fun process (c : command) : datum =
  case c of
    Go { d } =>
      return success_command ("go", Atom { "" })
  | Take { item } => [
      case room_from_name (INVENTORY) of
        NoRoom { } =>
          return failed_command ("take",
                                 describe_item (item),
                                 "internal error (report for maintenance!)")
      | SomeRoom { inventory } => [
        case item_portable (item) of
          True { } => [
            let items = room_items (inventory).
            case room_items (here ()) of
              NoItems { } =>
               return failed_command ("take", describe_item (item),
                                      "internal error (report for maintenance!)")
            | SomeItems { item', items' } => [
                case item_equals (item, item') of
                  True { } => [
                    do move_item_to_room (item, inventory).
                    return success_command ("take", describe_item (item))
                  ]
                | False { } => (* Not the top item *)
                    return failed_command ("take", describe_item (item),
                      "there is another item on top of it (take the other item first)")
            ]
          ]
        | False { } =>
          return failed_command ("take",
                                 describe_item (item),
                                 "it's impossible to do so").
      ]
    ]
  | Incinerate { item } =>
      return success_command ("incinerate", describe_item (item))
  | Combine { item1, item2 } =>
      return combine_items (item1, item2, False { })
  | Break { item } =>
      return success_command ("break", describe_item (item))
  | Drop { item } =>
      return success_command ("drop", describe_item (item))
  | Use { item } =>
      return failed_command ("use", describe_item (item),
                             "nothing interesting happens")
  | Whistle { } =>
      return success_command ("whistle", NoData { })
  | Hum { } => [
      case room_from_name ("Rotunda") of
        NoRoom { } => return success_command ("hum", NoData { })
      | SomeRoom { r } => [
          do move_self_to_room (r).
          return success_command ("hum", NoData { }).
        ]
    ]
  | Speak { s } => [
      case room_from_name("Rotunda") of 
        NoRoom { } => return success_command ("speak", Atom { s })
      | SomeRoom { room } => [
        case room_items (room) of
          NoItems { } => return success_command ("speak", Atom { s })
        | SomeItems { item, items } => [
          let content = item_description (item).
          let index = 0.
          case string_charat (content, index) = string_charat(s, 0) of
            False { } =>
              return success_command ("speak", Atom { s })
          | True { } => [
            case room_from_name (INVENTORY) of
              NoRoom { } =>
                return success_command ("speak", Atom { s })
            | SomeRoom { inventory } => [
              case room_items (inventory) of
                NoItems { } =>
                  return success_command ("speak", Atom { s })
              | SomeItems { uploader, is } => [
                do move_item_to_room (uploader, here ()).
                return success_command ("speak", Atom { s })
	      ]
            ]
          ]
        ]
      ]
    ]
  | LookAround { } =>
      return success_command ("look", Atom { "" })
  | ShowInventory { } => [
      return failed_command ("show", NoData { }, "")
  ]
  | Examine { item } => [
      return success_command ("examine", Atom {""}).
  ].
EOM
hum
